import itertools
import numpy as np
from timeit import timeit

def generate_recursive(K, T, target_sum):
    total = K * T
    res = []

    def backtrack(current):
        if len(current) == total:
            matrix = np.array(current).reshape(K, T)
            if all(np.sum(row) == target_sum for row in matrix):
                res.append(matrix)
            return
        for num in [0, 1, 2]:
            backtrack(current + [num])

    backtrack([])
    return res

def generate_itertools(K, T, target_sum):
    combs = itertools.product([0, 1, 2], repeat=K * T)
    valid_combs = []
    for c in combs:
        matrix = np.array(c).reshape(K, T)
        if all(np.sum(row) == target_sum for row in matrix):
            valid_combs.append(matrix)
    return valid_combs

def find_optimal_solution(solutions):
    if not solutions:
        return None
    return min(solutions, key=lambda x: np.sum(x))

K, T = 2, 2
target_sum = 3
num_runs = 100

recursive_time = timeit(
    lambda: generate_recursive(K, T, target_sum),
    number=num_runs
) / num_runs

itertools_time = timeit(
    lambda: generate_itertools(K, T, target_sum),
    number=num_runs
) / num_runs

print(f"Recursive method: {recursive_time:.6f} sec (average)")
print(f"itertools: {itertools_time:.6f} sec (average)")
print(f"\nitertools is faster by {recursive_time / itertools_time:.1f} times")

recursive_solutions = generate_recursive(K, T, target_sum)
itertools_solutions = generate_itertools(K, T, target_sum)

optimal_recursive = find_optimal_solution(recursive_solutions)
optimal_itertools = find_optimal_solution(itertools_solutions)

print("\nOptimal solution (recursive method):")
print(optimal_recursive)
print("\nOptimal solution (itertools):")
print(optimal_itertools)
