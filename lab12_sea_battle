import tkinter as tk
import random

SIZE = 10

def place_ships():
    board_cells, ships = set(), []
    # sizes = [4, 3, 3, 2, 2, 2, 1, 1, 1, 1] - используемый список
    for size in [4, 3, 3, 2, 2, 2, 1, 1, 1, 1]:
        placed = False
        for _ in range(200):
            h = random.choice([True, False])
            x = random.randint(0, SIZE - (size if h else 1))
            y = random.randint(0, SIZE - (size if not h else 1))
            cells = {(x + (i if h else 0), y + (i if not h else 0)) for i in range(size)}
            # Проверка, что вокруг новой ячейки нет других кораблей (включая диагонали)
            if all((cx + dx, cy + dy) not in board_cells for cx, cy in cells for dx in (-1, 0, 1) for dy in (-1, 0, 1)):
                ships.append(cells);
                board_cells |= cells;
                placed = True;
                break
        # На случай, если корабль не удалось разместить за 200 попыток (крайне маловероятно)
        if not placed: ships.append(cells); board_cells |= cells
    return ships

class Board:
    def __init__(self):
        self.ships, self.shots = place_ships(), set()

    def shoot(self, pos):
        if pos in self.shots: return None
        self.shots.add(pos)
        for s in self.ships:
            if pos in s: 
                # Проверка, затонул ли корабль
                if s <= self.shots:
                    # Помечаем все клетки вокруг затонувшего корабля как промахи
                    for cx, cy in s:
                        for dx in (-1, 0, 1):
                            for dy in (-1, 0, 1):
                                self.shots.add((cx + dx, cy + dy))
                    return "sunk"
                return "hit"
        return "miss"

    def all_sunk(self):
        return all(s <= self.shots for s in self.ships)

class AI:
    def __init__(self):
        self.board, self.targets, self.used = Board(), [], set()

    def shoot(self):
        # Если есть цели (режим "охоты" после попадания)
        if self.targets: 
            return self.targets.pop()
        # Иначе выбираем случайную клетку (режим "поиска")
        allp = [(x, y) for x in range(SIZE) for y in range(SIZE) if (x, y) not in self.used]
        # Используем стратегию "четных" клеток для ускорения поиска (опционально, убрано для простоты)
        return random.choice(allp) if allp else (0, 0)

    def feedback(self, pos, res):
        self.used.add(pos)
        if res == "hit":
            x, y = pos
            # Добавляем соседние клетки как цели для продолжения стрельбы
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < SIZE and 0 <= ny < SIZE and (nx, ny) not in self.used:
                    self.targets.append((nx, ny))
        elif res == "sunk":
            # После потопления корабля сбрасываем цели
            self.targets.clear()

class Game:
    def __init__(self, root):
        self.root, self.player, self.ai = root, Board(), AI()
        self.root.title("Морской бой")
        self.setup_ui()
        self.restart() # Запускаем первую игру

    def setup_ui(self):
        # ИЗМЕНЕНИЕ: Фон фрейма
        f = tk.Frame(self.root, bg="#f0f0f0");
        f.pack(padx=10, pady=10)
        self.status = tk.Label(f, text="Начните игру!", font=("Arial", 14, "bold"), fg="navy");
        self.status.grid(row=0, column=0, columnspan=22, pady=5)
        
        tk.Label(f, text="Мой флот", font=("Arial", 11, "bold")).grid(row=1, column=0, columnspan=10)
        tk.Label(f, text="Флот противника", font=("Arial", 11, "bold")).grid(row=1, column=12, columnspan=10)
        
        # Создаём разделительный столбец
        f.grid_columnconfigure(10, minsize=40)
        f.grid_columnconfigure(11, minsize=1)
        
        self.p_btns, self.e_btns = [], []
        for y in range(SIZE):
            row_p, row_e = [], []
            for x in range(SIZE):
                # ИЗМЕНЕНИЕ: Стиль кнопок для игрового поля
                style = {"width": 2, "height": 1, "relief": "raised", "bd": 1}

                # Поле игрока (My board)
                b_p = tk.Button(f, **style, bg="#b0e0e6", state="disabled") # Светло-голубой
                b_p.grid(row=y + 2, column=x);
                row_p.append(b_p)

                # Поле противника (Enemy board)
                b_e = tk.Button(f, **style, bg="#b0e0e6", command=lambda x=x, y=y: self.shot(x, y)) # Светло-голубой
                b_e.grid(row=y + 2, column=x + 12);
                row_e.append(b_e)
                
            self.p_btns.append(row_p);
            self.e_btns.append(row_e)
            
        tk.Button(f, text="Новая игра", command=self.restart, font=("Arial", 11)).grid(row=12, column=0, columnspan=22, pady=10)

    def update(self):
        # Обновление поля игрока
        for y in range(SIZE):
            for x in range(SIZE):
                p, e = self.p_btns[y][x], self.e_btns[y][x]
                pos = (x, y)
                
                # --- Обновление поля игрока ---
                is_ship = any(pos in s for s in self.player.ships)
                is_shot = pos in self.player.shots
                
                if is_ship and is_shot:
                    # Попадание по нашему кораблю
                    p.config(bg="#cc0000") 
                elif is_ship:
                    # Наш целый корабль
                    p.config(bg="#38761d") 
                elif is_shot:
                    # Промах по нашему полю
                    p.config(bg="#808080") 
                else:
                    # Вода
                    p.config(bg="#b0e0e6") 

                # --- Обновление поля противника ---
                is_enemy_shot = pos in self.ai.board.shots
                is_enemy_ship = any(pos in s for s in self.ai.board.ships)
                
                if is_enemy_shot:
                    e.config(state="disabled")
                    if is_enemy_ship:
                        # Попадание по вражескому кораблю
                        e.config(bg="#cc0000") 
                        # Промах по вражескому полю
                        e.config(bg="#808080") 

    def shot(self, x, y):
        # Выстрел игрока
        if self.ai.board.shoot((x, y)) is None: return
        # Ход ИИ
        ai_pos = self.ai.shoot()
        ai_res = self.player.shoot(ai_pos) # Получаем результат выстрела ИИ
        # Обновление обратной связи ИИ
        self.ai.feedback(ai_pos, ai_res)
        
        self.update()
        
        # Проверка конца игры
        if self.ai.board.all_sunk():
            self.status.config(text="Победа!", fg="green")
            self.disable_enemy_board()
        elif self.player.all_sunk():
            self.status.config(text="Поражение!", fg="red")
            self.disable_enemy_board()

    def disable_enemy_board(self):
        for row in self.e_btns:
            for btn in row:
                btn.config(state="disabled")

    def restart(self):
        self.player, self.ai = Board(), AI()
        self.status.config(text="Сделайте свой ход", fg="navy")
        # Включаем все кнопки противника и обновляем поле
        for row in self.e_btns:
            for btn in row:
                btn.config(state="normal")
        self.update()

root = tk.Tk()
Game(root)
root.mainloop()
