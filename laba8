import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import csv
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg


class RentalContract:
    # Инициализация оставлена без изменений, так как она понятна и необходима.
    def __init__(self, contract_id, client_name, car_model, car_class, manager, duration_days, price):
        self.contract_id = contract_id
        self.client_name = client_name
        self.car_model = car_model
        self.car_class = car_class
        self.manager = manager
        self.duration_days = duration_days
        self.price = price

    def __str__(self):
        return (f"Договор №{self.contract_id}: {self.client_name} арендует {self.car_model} "
                f"({self.car_class}) на {self.duration_days} дней, менеджер: {self.manager}")


class RentalApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Управление договорами аренды автомобилей")
        self.contracts = []
        self.create_widgets()

    def create_widgets(self):

        input_frame = ttk.LabelFrame(self.root, text="Добавить договор")
        input_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        entries = [
            ("Номер договора:", "contract_id_entry"),
            ("Клиент:", "client_entry"),
            ("Модель авто:", "car_model_entry"),
            ("Класс авто:", "car_class_combobox", ["Эконом", "Стандарт", "Премиум", "Внедорожник"]),
            ("Менеджер:", "manager_combobox", ["Иванов", "Петрова", "Сидоров", "Кузнецова"]),
            ("Срок (дни):", "duration_entry"),
            ("Цена:", "price_entry"),
        ]


        row_idx = 0
        for item in entries:
            ttk.Label(input_frame, text=item[0]).grid(row=row_idx, column=0, sticky="w")
            if len(item) == 2:
                widget = ttk.Entry(input_frame)
            else:
                widget = ttk.Combobox(input_frame, values=item[2])
            setattr(self, item[1], widget)
            widget.grid(row=row_idx, column=1, padx=5, pady=2)
            row_idx += 1
            
        ttk.Button(input_frame, text="Добавить", command=self.add_contract).grid(row=row_idx, column=0, columnspan=2, pady=5)
        ttk.Button(input_frame, text="Загрузить из файла", command=self.load_from_file).grid(row=row_idx + 1, column=0, columnspan=2, pady=5)
        ttk.Button(input_frame, text="Сохранить в файл", command=self.save_to_file).grid(row=row_idx + 2, column=0, columnspan=2, pady=5)
        
        display_frame = ttk.LabelFrame(self.root, text="Список договоров")
        display_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        
        self.tree = ttk.Treeview(display_frame, columns=("ID", "Client", "Car", "Class", "Manager", "Days", "Price"), show="headings")
        headings = [("ID", "Номер", 50), ("Client", "Клиент", 100), ("Car", "Авто", 100), ("Class", "Класс", 80), ("Manager", "Менеджер", 80), ("Days", "Дни", 50), ("Price", "Цена", 70)]

        # Сокращенное назначение заголовков и ширины столбцов
        for col_id, text, width in headings:
            self.tree.heading(col_id, text=text)
            self.tree.column(col_id, width=width)
        
        self.tree.pack(fill="both", expand=True)
        
        analysis_frame = ttk.LabelFrame(self.root, text="Анализ данных")
        analysis_frame.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")
        
        ttk.Button(analysis_frame, text="Сегментация по классам авто", command=self.analyze_by_class).grid(row=0, column=0, padx=5, pady=5)
        ttk.Button(analysis_frame, text="Сегментация по менеджерам", command=self.analyze_by_manager).grid(row=0, column=1, padx=5, pady=5)
        ttk.Button(analysis_frame, text="Показать все договоры", command=self.display_contracts).grid(row=0, column=2, padx=5, pady=5)
        
        self.figure = plt.figure(figsize=(5, 4), dpi=100)
        self.canvas = FigureCanvasTkAgg(self.figure, master=analysis_frame)
        self.canvas.get_tk_widget().grid(row=1, column=0, columnspan=3, pady=10)
        
        self.root.columnconfigure(0, weight=1)
        self.root.columnconfigure(1, weight=1)
        self.root.rowconfigure(0, weight=1)
        self.root.rowconfigure(1, weight=1)

    
    
    def add_contract(self):
        """Добавление нового договора"""
        try:
            fields = [
                self.contract_id_entry.get().strip(),
                self.client_entry.get().strip(),
                self.car_model_entry.get().strip(),
                self.car_class_combobox.get().strip(),
                self.manager_combobox.get().strip(),
                self.duration_entry.get().strip(),
                self.price_entry.get().strip(),
            ]
            
            if not all(fields):
                raise ValueError("Все поля должны быть заполнены.")
            
            contract_id, client, car_model, car_class, manager, duration_str, price_str = fields

            if any(c.contract_id == contract_id for c in self.contracts):
                raise ValueError(f"Договор с номером {contract_id} уже существует.")
            
            try:
                duration = int(duration_str)
                if duration <= 0:
                    raise ValueError("Срок (дни) должен быть положительным целым числом.")
            except ValueError:
                raise ValueError("Срок (дни) должен быть целым числом.")
            
            try:
                price = float(price_str)
                if price <= 0:
                    raise ValueError("Цена должна быть положительным числом.")
            except ValueError:
                raise ValueError("Цена должна быть числом.")

            new_contract = RentalContract(contract_id, client, car_model, car_class, manager, duration, price)
            self.contracts.append(new_contract)
            self.display_contracts()

            entries = [self.contract_id_entry, self.client_entry, self.car_model_entry, self.duration_entry, self.price_entry]
            for entry in entries:
                entry.delete(0, tk.END)
            # Очистка комбобоксов
            self.car_class_combobox.set('')
            self.manager_combobox.set('')
            
            messagebox.showinfo("Успех", "Договор успешно добавлен")
        except ValueError as e:
            messagebox.showerror("Ошибка", f"Некорректные данные: {e}")
    
    def display_contracts(self):
        """Отображение всех договоров в таблице"""
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        for contract in self.contracts:
            self.tree.insert("", tk.END, values=(
                contract.contract_id,
                contract.client_name,
                contract.car_model,
                contract.car_class,
                contract.manager,
                contract.duration_days,
                contract.price
            ))

    def analyze_by_class(self):
        """Анализ по классам автомобилей"""
        if not self.contracts:
            messagebox.showwarning("Предупреждение", "Нет данных для анализа")
            return
        
        class_counts = {}
        for contract in self.contracts:
            class_counts[contract.car_class] = class_counts.get(contract.car_class, 0) + 1
        
        self.show_pie_chart(
            class_counts, 
            title="Распределение договоров по классам автомобилей",
            colors=['#ff9999','#66b3ff','#99ff99','#ffcc99']
        )
    
    def analyze_by_manager(self):
        """Анализ по менеджерам"""
        if not self.contracts:
            messagebox.showwarning("Предупреждение", "Нет данных для анализа")
            return
        
        manager_counts = {}
        for contract in self.contracts:
            manager_counts[contract.manager] = manager_counts.get(contract.manager, 0) + 1
        
        self.show_pie_chart(
            manager_counts, 
            title="Распределение договоров по менеджерам",
            colors=['#ff9999','#66b3ff','#99ff99','#ffcc99']
        )
    
    def show_pie_chart(self, data_dict, title, colors=None):
        """Отображение круговой диаграммы"""
        labels = list(data_dict.keys())
        sizes = list(data_dict.values())
        
        self.figure.clear()
        ax = self.figure.add_subplot(111)

        pie_kwargs = {'labels': labels, 'autopct': '%1.1f%%', 'startangle': 90}
        if colors:
            pie_kwargs['colors'] = colors
            
        ax.pie(sizes, **pie_kwargs)
        
        ax.axis('equal')
        ax.set_title(title)
        self.canvas.draw()
    
    def load_from_file(self):
        """Загрузка данных из файла"""
        file_path = filedialog.askopenfilename(
            title="Выберите файл с данными",
            filetypes=(("CSV файлы", "*.csv"), ("Текстовые файлы", "*.txt"), ("Все файлы", "*.*"))
        )
        
        if not file_path:
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                reader = csv.reader(file)
                next(reader, None)  # Пропускаем заголовок, используя None для безопасности
                
                new_contracts = []
                # Сокращение: использование генераторного выражения и списка для фильтрации
                for row in reader:
                    if len(row) == 7:
                        try:
                            # Создание объекта с приведением типов
                            contract = RentalContract(
                                row[0].strip(),
                                row[1].strip(),
                                row[2].strip(),
                                row[3].strip(),
                                row[4].strip(),
                                int(row[5].strip()),
                                float(row[6].strip())
                            )
                            new_contracts.append(contract)
                        except (ValueError, IndexError):
                            continue
                
                if new_contracts:
                    self.contracts = new_contracts
                    self.display_contracts()
                    messagebox.showinfo("Успех", f"Загружено {len(new_contracts)} договоров")
                else:
                    messagebox.showwarning("Предупреждение", "Не удалось загрузить данные из файла")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка при загрузке файла: {e}")
    
    def save_to_file(self):
        """Сохранение данных в файл"""
        if not self.contracts:
            messagebox.showwarning("Предупреждение", "Нет данных для сохранения")
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Сохранить данные",
            defaultextension=".csv",
            filetypes=(("CSV файлы", "*.csv"), ("Текстовые файлы", "*.txt"), ("Все файлы", "*.*"))
        )
        
        if not file_path:
            return
        
        try:
            with open(file_path, 'w', encoding='utf-8', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(["ID", "Client", "CarModel", "CarClass", "Manager", "Duration", "Price"])
                
                # Сокращение: использование генератора для записи строк
                rows_to_write = (
                    (c.contract_id, c.client_name, c.car_model, c.car_class, c.manager, c.duration_days, c.price)
                    for c in self.contracts
                )
                writer.writerows(rows_to_write)
            
            messagebox.showinfo("Успех", f"Данные сохранены в файл: {file_path}")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка при сохранении файла: {e}")


if __name__ == "__main__":
    root = tk.Tk()
    app = RentalApp(root)
    root.mainloop()
